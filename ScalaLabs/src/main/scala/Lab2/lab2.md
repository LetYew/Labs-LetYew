# Лабораторная работа 2

Отчёт по лабе:
1. Титульник
2. Цель 
3. Вариант
4. Ход работ: поясняйте, что сделано, какие решения приняты и почему.
5. Вывод
6. Приложение: листинги кода и примеры работы

Отчёт по лабораторной сдаётся в электронном виде.

Задача лабораторной работы состоит в том, 
чтобы написать корректно работающую реализацию программы, 
в соответствии с вариантом.

В большинстве вариантов задача решается в 2 этапа: 
1. На первом этапе потоки работают параллельно и формируют частичные результаты
2. На втором этапе полученные результаты объединяются в общий результат.

Первый этап обязателен для всех. Агрегировать результаты также нужно выполнить всем, 
но есть выбор: агрегировать результаты в основном потоке или каким-либо образом выполнить агрегацию параллельно.

Вместе с вариантом лабораторной работы даётся сигнатура функции. 
От неё можно отходить, но если это возможно - не рекомендуется.

## Варианты
### Вариант 1
Численное интегрирование монотонной функции методом монте-карло:
строите прямогольник "накрывающий" нужный отрезок функции и "кидаете" точки в сулчайные места.
Отношение точек ближе к Ох чем функция и всех точек ~= отношеню площади под графиком функции и всей площади прямоугольника.
```scala
def integralMonteCarlo(f:Double=>Double, l:Double, r:Double, pointsNumber:Int, threadsNumber:Int):Double
```
### Вариант 2
Вычисление числа Пи методом монтекарло:
Вам нужна единичная окружность и её описанный квадрат. Далее действуейте примерно как в варианте 1.
```scala
def piMonteCarlo(pointsNumber:Int, threadsNumber:Int):Double
```
### Вариант 3
Перемножение матриц:
Можно взять библиотечную реализацию, 
написать свою, либо просто использовать `Seq[Seq[Double]]` или `Array[Array[Double]]`
```scala
type Matrix = Seq[Seq[Double]] // или Array[Array[Double]] или ещё какая-то матрица
def matrixProduct(m1:Matrix, m2:Matrix,threadsNumber:Int):Double
```
### Вариант 4
Вычислить срденее массива:
Большой массив делится на части. В каждой считается среднее. Результаты объединяются.
```scala
def average(data:Seq[Double], threadsNumber:Int):Double
```
### Вариант 5
Расчёт частотностей элементов в массиве:
Ваша задача: построить гистограмму.
```scala
case class Gist(min:Int, max:Int, gist:Seq[Int])
//min и max - минимальный и максимальный элементы в коллекции. Задаются внешне
def gist(min:Int, max:Int, data:Seq[Double], threadsNumber:Int):Gist
```
### Вариант 6
Сортировка подсчётом:
Отсортируйте массив, разделив его на части.
```scala
//min и max - минимальный и максимальный элементы в коллекции. Задаются внешне
def bucketSort(min:Int, max:Int, data:Seq[Double], threadsNumber:Int):Seq[Double]
```
### Вариант 7
Нормализация значений массива:
Параллельно посчитать минимум и максимум массива и поделить все элементы на разницу и переместить в диапозон от 0 до 1
```scala
def normalize(data:Seq[Double], threadsNumber:Int):Seq[Double]
```
### Вариант 8
Дана коллекция. Посчитать количество пар элементов коллекции, удволетворяющих предикату p
```scala
def count[T](data:Seq[Double], pred:T=>Boolean, threadsNumber:Int):Int
```
### Вариант 9
Посчитать уникальные элементы массива
```scala
def countUnique[T](data:Seq[Double], threadsNumber:Int):Int
```